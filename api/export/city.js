// Vercel API route for city data export
import { Parser } from "json2csv";
import { cityCoordinates } from '../data/cityCoordinates.js';
import { cityPollutionData } from '../data/cityPollutionData.js';
import airVisualClient from '../utils/airVisualClient.js';
import {
  getRiskLevel,
  getDiseasesByRisk,
  calculateOverallAQI,
  getAQICategory,
  getRiskFromAQI,
  getDetailedDiseases,
  getHealthRecommendations,
} from '../utils/healthRisk.js';
import { getAdvisory } from '../utils/advisory.js';

// Helper function to generate CSV data
function generateCSVData(data, type = "city") {
  const json2csvParser = new Parser();
  
  if (type === "city") {
    // Format city data for CSV
    const csvData = [{
      city: data.city,
      state: data.state,
      area: data.area || "N/A",
      latitude: data.coordinates.lat,
      longitude: data.coordinates.lng,
      aqi: data.aqi,
      aqi_category: data.aqiCategory,
      pm25: data.pm25,
      pm10: data.pm10,
      o3: data.o3 || "N/A",
      no2: data.no2 || "N/A",
      so2: data.so2 || "N/A",
      co: data.co || "N/A",
      health_risk: data.risk,
      diseases: data.diseases.join("; "),
      advisory: data.advisory,
      last_updated: data.lastUpdated,
      data_source: data.source,
      location_type: data.locationType
    }];
    return json2csvParser.parse(csvData);
  }
  
  return "";
}

// Helper function to generate PDF report (simplified for serverless)
function generatePDFData(data) {
  // In a serverless environment, we'll return structured data that can be converted to PDF on client side
  // or use a simpler text format for now
  return `Air Quality & Health Report
  
Location: ${data.city}${data.area ? `, ${data.area}` : ''}
State: ${data.state}
Coordinates: ${data.coordinates.lat.toFixed(4)}, ${data.coordinates.lng.toFixed(4)}
Last Updated: ${new Date(data.lastUpdated).toLocaleString()}
Data Source: ${data.source || 'Static Data'}

Air Quality Index (AQI)
Current AQI: ${data.aqi}
Category: ${data.aqiCategory}
Health Risk: ${data.risk}

Pollutant Concentrations
PM2.5: ${data.pm25} µg/m³
PM10: ${data.pm10} µg/m³
${data.o3 ? `O₃: ${data.o3} µg/m³` : ''}
${data.no2 ? `NO₂: ${data.no2} µg/m³` : ''}
${data.so2 ? `SO₂: ${data.so2} µg/m³` : ''}
${data.co ? `CO: ${data.co} µg/m³` : ''}

Health Impact
Associated Diseases: ${data.diseases.join(', ')}
Health Advisory: ${data.advisory}

Generated by SDG-3 Air Quality Dashboard
For awareness and prevention only. Not medical diagnosis.`;
}

// Helper function to fetch city data (reusing logic from city.js)
async function fetchCityData(city, state, area) {
  // This is a simplified version - in production you'd want to reuse the full city data logic
  const cityKey = city;
  const coords = cityCoordinates[cityKey];
  
  if (!coords) {
    throw new Error("City not supported");
  }
  
  // Simple fallback data for demonstration
  const pollution = cityPollutionData[cityKey] || {
    pm25: 45,
    pm10: 78,
    o3: 30,
    no2: 25,
    so2: 15,
    co: 400
  };
  
  const aqi = calculateOverallAQI(pollution);
  const aqiInfo = getAQICategory(aqi);
  const risk = getRiskFromAQI(aqi);
  const diseases = getDiseasesByRisk(risk);
  const detailedDiseases = getDetailedDiseases(aqi);
  const healthRecommendations = getHealthRecommendations(aqi);
  const advisory = getAdvisory(risk);
  const chartData = [];
  
  return {
    state: state || "Rajasthan",
    city: cityKey,
    area: area || null,
    coordinates: { lat: coords.lat, lng: coords.lng },
    pm25: pollution.pm25,
    pm10: pollution.pm10,
    o3: pollution.o3,
    no2: pollution.no2,
    so2: pollution.so2,
    co: pollution.co,
    aqi,
    aqiCategory: aqiInfo.category,
    aqiColor: aqiInfo.color,
    risk,
    diseases,
    detailedDiseases,
    healthRecommendations,
    chartData,
    advisory,
    disclaimer: "For awareness and prevention only. Not medical diagnosis.",
    lastUpdated: new Date().toISOString(),
    source: "static-data",
    fallbackUsed: true,
    locationType: area ? "area" : "city",
    locationAttempted: area || cityKey
  };
}

export default async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { city, state, area, format = "csv" } = req.query;
    
    if (!city || !state) {
      return res.status(400).json({ error: "City and state are required" });
    }
    
    // Fetch city data
    const data = await fetchCityData(city, state, area);
    
    // Generate appropriate response based on format
    if (format === "json") {
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Content-Disposition', `attachment; filename=${city}_data.json`);
      return res.status(200).json(data);
    } else if (format === "pdf") {
      // For PDF in serverless, we'll return text format that can be converted client-side
      res.setHeader('Content-Type', 'text/plain');
      res.setHeader('Content-Disposition', `attachment; filename=${city}_health_report.txt`);
      const pdfContent = generatePDFData(data);
      return res.status(200).send(pdfContent);
    } else {
      // Default to CSV
      const csv = generateCSVData(data, "city");
      res.setHeader('Content-Type', 'text/csv');
      res.setHeader('Content-Disposition', `attachment; filename=${city}_data.csv`);
      return res.status(200).send(csv);
    }
    
  } catch (error) {
    console.error("Export error:", error);
    res.status(500).json({ error: "Failed to export data" });
  }
}