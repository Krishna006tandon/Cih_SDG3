// Vercel API route for city data export
import { cityCoordinates } from '../data/cityCoordinates.js';
import { cityPollutionData } from '../data/cityPollutionData.js';

// Helper function to generate CSV data
function generateCSVData(data, type = "city") {
  if (type === "city") {
    // Format city data for CSV manually
    const headers = [
      'city', 'state', 'area', 'latitude', 'longitude', 'aqi', 'aqi_category',
      'pm25', 'pm10', 'o3', 'no2', 'so2', 'co', 'health_risk', 'diseases',
      'advisory', 'last_updated', 'data_source', 'location_type'
    ];
    
    const values = [
      data.city,
      data.state,
      data.area || "N/A",
      data.coordinates.lat,
      data.coordinates.lng,
      data.aqi,
      data.aqiCategory,
      data.pm25,
      data.pm10,
      data.o3 || "N/A",
      data.no2 || "N/A",
      data.so2 || "N/A",
      data.co || "N/A",
      data.risk,
      data.diseases.join("; "),
      data.advisory,
      data.lastUpdated,
      data.source,
      data.locationType
    ];
    
    return headers.join(',') + '\n' + values.map(v => `"${String(v).replace(/"/g, '""')}"`).join(',');
  }
  
  return "";
}

// Helper function to generate PDF report (simplified for serverless)
function generatePDFData(data) {
  // In a serverless environment, we'll return structured data that can be converted to PDF on client side
  // or use a simpler text format for now
  return `Air Quality & Health Report
  
Location: ${data.city}${data.area ? `, ${data.area}` : ''}
State: ${data.state}
Coordinates: ${data.coordinates.lat.toFixed(4)}, ${data.coordinates.lng.toFixed(4)}
Last Updated: ${new Date(data.lastUpdated).toLocaleString()}
Data Source: ${data.source || 'Static Data'}

Air Quality Index (AQI)
Current AQI: ${data.aqi}
Category: ${data.aqiCategory}
Health Risk: ${data.risk}

Pollutant Concentrations
PM2.5: ${data.pm25} µg/m³
PM10: ${data.pm10} µg/m³
${data.o3 ? `O₃: ${data.o3} µg/m³` : ''}
${data.no2 ? `NO₂: ${data.no2} µg/m³` : ''}
${data.so2 ? `SO₂: ${data.so2} µg/m³` : ''}
${data.co ? `CO: ${data.co} µg/m³` : ''}

Health Impact
Associated Diseases: ${data.diseases.join(', ')}
Health Advisory: ${data.advisory}

Generated by SDG-3 Air Quality Dashboard
For awareness and prevention only. Not medical diagnosis.`;
}

// Simple AQI calculation function
function calculateOverallAQI(pollutants) {
  // Simplified AQI calculation
  const pm25Aqi = Math.round((pollutants.pm25 / 100) * 100);
  const pm10Aqi = Math.round((pollutants.pm10 / 150) * 100);
  return Math.max(pm25Aqi, pm10Aqi, 20);
}

// Simple AQI category function
function getAQICategory(aqi) {
  if (aqi <= 50) return { category: "Good", color: "#22c55e" };
  if (aqi <= 100) return { category: "Satisfactory", color: "#84cc16" };
  if (aqi <= 200) return { category: "Moderate", color: "#eab308" };
  if (aqi <= 300) return { category: "Poor", color: "#f97316" };
  if (aqi <= 400) return { category: "Very Poor", color: "#ef4444" };
  return { category: "Severe", color: "#7e22ce" };
}

// Simple risk function
function getRiskFromAQI(aqi) {
  if (aqi <= 100) return "Low";
  if (aqi <= 200) return "Medium";
  return "High";
}

// Simple diseases function
function getDiseasesByRisk(risk) {
  if (risk === "High") return ["Asthma", "COPD", "Lung Cancer", "Heart Disease", "Stroke"];
  if (risk === "Medium") return ["Asthma", "Respiratory Infections"];
  return ["Normal respiratory function"];
}

// Simple advisory function
function getAdvisory(risk) {
  if (risk === "High") return "Children and elderly should avoid outdoor exertion. Everyone else should limit outdoor activities.";
  if (risk === "Medium") return "Sensitive groups should limit outdoor activities.";
  return "Air quality is acceptable for most activities.";
}

// Helper function to fetch city data from main API
async function fetchCityData(city, state, area) {
  try {
    // Call the main city API endpoint to get real data
    const requestBody = { state, city };
    if (area) requestBody.area = area;
    
    const response = await fetch('https://cih-sdg-3.vercel.app/api/city', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody)
    });
    
    if (!response.ok) {
      throw new Error(`API request failed with status ${response.status}`);
    }
    
    const data = await response.json();
    
    // Return the real data with proper export formatting
    return {
      state: data.state,
      city: data.city,
      area: data.area || null,
      coordinates: data.coordinates,
      pm25: data.pm25,
      pm10: data.pm10,
      o3: data.o3,
      no2: data.no2,
      so2: data.so2,
      co: data.co,
      aqi: data.aqi,
      aqiCategory: data.aqiCategory,
      aqiColor: data.aqiColor,
      risk: data.risk,
      diseases: data.diseases,
      detailedDiseases: data.detailedDiseases || [],
      healthRecommendations: data.healthRecommendations || {},
      chartData: data.chartData || [],
      advisory: data.advisory,
      disclaimer: data.disclaimer || "For awareness and prevention only. Not medical diagnosis.",
      lastUpdated: data.lastUpdated || new Date().toISOString(),
      source: data.source || "api-data",
      fallbackUsed: data.fallbackUsed || false,
      locationType: data.locationType || (area ? "area" : "city"),
      locationAttempted: data.locationAttempted || area || city
    };
    
  } catch (error) {
    console.error("Failed to fetch real data, using fallback:", error.message);
    
    // Fallback to static data if API call fails
    const cityKey = city;
    const coords = cityCoordinates[cityKey];
    
    if (!coords) {
      throw new Error("City not supported");
    }
    
    const pollution = cityPollutionData[cityKey] || {
      pm25: 45 + Math.random() * 80,
      pm10: 78 + Math.random() * 100,
      o3: 20 + Math.random() * 30,
      no2: 20 + Math.random() * 25,
      so2: 10 + Math.random() * 15,
      co: 300 + Math.random() * 500
    };
    
    const aqi = calculateOverallAQI(pollution);
    const aqiInfo = getAQICategory(aqi);
    const risk = getRiskFromAQI(aqi);
    const diseases = getDiseasesByRisk(risk);
    const advisory = getAdvisory(risk);
    
    return {
      state: state || "Rajasthan",
      city: cityKey,
      area: area || null,
      coordinates: { lat: coords.lat, lng: coords.lng },
      pm25: Math.round(pollution.pm25 * 10) / 10,
      pm10: Math.round(pollution.pm10 * 10) / 10,
      o3: Math.round(pollution.o3 * 10) / 10,
      no2: Math.round(pollution.no2 * 10) / 10,
      so2: Math.round(pollution.so2 * 10) / 10,
      co: Math.round(pollution.co * 10) / 10,
      aqi,
      aqiCategory: aqiInfo.category,
      aqiColor: aqiInfo.color,
      risk,
      diseases,
      detailedDiseases: [],
      healthRecommendations: {},
      chartData: [],
      advisory,
      disclaimer: "For awareness and prevention only. Not medical diagnosis.",
      lastUpdated: new Date().toISOString(),
      source: "static-data-fallback",
      fallbackUsed: true,
      locationType: area ? "area" : "city",
      locationAttempted: area || cityKey
    };
  }
}

export default async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { city, state, area, format = "csv" } = req.query;
    
    if (!city || !state) {
      return res.status(400).json({ error: "City and state are required" });
    }
    
    // Fetch city data
    const data = await fetchCityData(city, state, area);
    
    // Generate appropriate response based on format
    if (format === "json") {
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Content-Disposition', `attachment; filename=${city}_data.json`);
      return res.status(200).json(data);
    } else if (format === "pdf") {
      // For PDF in serverless, we'll return text format that can be converted client-side
      res.setHeader('Content-Type', 'text/plain');
      res.setHeader('Content-Disposition', `attachment; filename=${city}_health_report.txt`);
      const pdfContent = generatePDFData(data);
      return res.status(200).send(pdfContent);
    } else {
      // Default to CSV
      const csv = generateCSVData(data, "city");
      res.setHeader('Content-Type', 'text/csv');
      res.setHeader('Content-Disposition', `attachment; filename=${city}_data.csv`);
      return res.status(200).send(csv);
    }
    
  } catch (error) {
    console.error("Export error:", error);
    res.status(500).json({ error: "Failed to export data" });
  }
}